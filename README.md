# Optimizing Delivery Routes with Dijkstra's Algorithm

## Introduction

In general, the application of the **Dijkstra algorithm** is optimization in the problems of **computer networks**, **communication networks**, and **transport networks**. Theoretically, the **Dijkstra algorithm** is an algorithm used in determining routes in networks with minimum weight. This weight is the travel time, mileage, or cost needed during the trip through a route. This algorithm was found by **Edsger W. Dijkstra in 1956** (Ahmed, Ahmed, and Ahmed 2017). 

Thus, the **Dijkstra algorithm** can be used for the application of graph theory in the determination of the shortest route in the network of the package delivery service companies. The shortest route is generated by running the **Dijkstra algorithm** on the initial model graph, starting from the starting point to all other points and returning again to the starting point. Thus, this shortest route is a closed route traversed by a courier from a package delivery service company in a trip. 

#### Graph Theory in Delivery Optimization

The graphs used in this study are **simple and finite graphs**. A graph that is connected and its edges have a weight is called a **connected weighted graph**. This initial model graph is a connected weighted graph, where the weight is the mileage. We call a point in a graph a vertex. So, the starting point is the starting vertex. The shortest closed route generated from this algorithm can be either a **cycle** or a **circuit**. 

A cycle is a closed route that visits a vertex once, otherwise, it is a circuit. For example, **𝐶1 = (2, 3, 4, 2)** is a cycle, but **𝐶2 = (1, 2, 3, 4, 2, 3, 5, 1)** is a circuit in a graph, where **{1, 2, 3, 4, 5}** is a vertex set of this graph (Chartrand, Lesniak, and Zhang 2016).

#### Importance of Route Optimization

Optimal distribution management capabilities will have a major impact on all aspects, especially for freight package delivery service companies. Recently, there have been several studies related to delivery service optimization, namely the problem of routing vehicles with drones for delivery services using **ant colony optimization algorithms** (Huang et al. 2022), integrating clustering methodologies and routing optimization algorithms for last-mile parcel delivery (Ramírez-Villamil et al. 2022), multi-objective optimization of bicycle routes for last-mile package delivery with drop-off (Osaba et al. 2018), synchronized 
truck and drone routing in package delivery logistics (Das et al. 2020), and a multi-objective optimization approach to package delivery by the crowd of occupied taxis (Zhou et al. 2022).

In this article, we will determine the shortest route for delivery service by **PosLaju Malaysia** in **Selangor** using the **Dijkstra algorithm**.


## Proof of Correctness for Dijkstra's Algorithm:

**Claim:** In Dijkstra's Algorithm, when a vertex `u` is included in the reached set, the distance computed by the algorithm `D(S , u)` is equal to the actual minimum distance `d(S , u)` from the source `S` to `u`.

**Proof:** (by contradiction)

Let's suppose the statement is false. That implies there exist some vertices for which, when `u` is included in the reached set, we have:

*D(S , u) > d(S , u)*

Let's denote `x` as the first vertex among these where this inequality holds, and assume `x` was included in the reached set.

This implies that all previous vertices, `z`, included in the reached set have:

*D(S ,z) = d(S , z)*
 
Now, let's consider the moment when vertex `x` is included in the reached set:

- Let `P` be the actual shortest path from `S` to `x`.
- Let `z` be the first vertex not in the reached set but on the shortest path `P`.
- Let `y` be the predecessor vertex of `z` on the shortest path `P`.

### Graphical depiction of the situation:

![image](https://github.com/badar24434/Delivery-Route-Optimization-Using-Dijkstra-s-Algorithm/assets/164218215/3a632eff-490d-4196-9802-3292bbf2f38f)

We have the following relations:

 *D(S , y) = d(S , y)*  (The min. distance `S ⇒ y` computed by the algorithm = actual min. distance `S ⇒ y` because `y` in included before `x`).


 *D(S , z) = D(S,y) + linkcost(y , z) 
 = d(S , y) + linkcost(y , z)*  (by how `z` was chosen).


 *D(S , x) ≤ D(S,z)*  (because `x` is included after `z`).

### A sub path of a shortest path is itself a shortest path


![image](https://github.com/badar24434/Delivery-Route-Optimization-Using-Dijkstra-s-Algorithm/assets/164218215/fa64bf1a-aac0-4ee6-9572-8ee775de3965)


Now, using the fact that a sub-path of a shortest path is itself a shortest path:

*d(S , x) = d(S , z) + d(z , x)*

We can now conclude:

*D(S , x) ≤ D(S , z)*
*= d(S , y) + linkcost(y , z)*
*≤ d(S , y) + linkcost(y , z) + d(z , x)*
*= d(S , x)*

This contradicts our assumption that *D(S , x) > d(S , x)*.

Therefore, our initial assumption must be false, and the statement holds *true* for **Dijkstra's Algorithm**.

# Methodology 

The model to be analysed is the case of a package delivery service carried out by a courier from a drop point of blabla. The number of customers served by a courier is more than 15 customers in one delivery trip depending on the density of demand. In this case, we will analysis for 17 customers in 12 locations in the blabla and blbla areas. Meanwhile, data about mileage is obtained from the Google Maps application. All this data is used to construct an initial model graph which is a connected weighted graph, where the location of the drop point or a customer is a vertex and the road connecting two locations is an edge of the graph. The weight in this graph is the distance travelled from the drop point to the customers or from one customer to another. We call the distance travelled is the mileage. Then, the Dijkstra algorithm is run on this graph where the drop point is the starting point of the route, such that the courier visits all customers and returns again to the drop point.

The flow of research methodology can be described as follows. First, collecting of customer location/address data. Then, processing location data into distance data travelled from one location to another. Second, constructing this data as an initial model i.e. a connected weighted graph. Third, running the Dijkstra algorithm on this graph so that the shortest route is obtained. This shortest route should visit all customers and return again to the drop point. Thus, this route is either a closed path (cycle) or a closed trail (circuit) that is a subgraph of the initial model graph.

The initial model graph is constructed from data on the number of customers, customer locations, the existence of roads connecting one location to another, road conditions travelled, and mileage between locations. The road connecting these locations must be passable by a motorcycle. In this model, if there is no road connecting 2 locations directly then there is no edge between the 2 locations. Thus, the initial model graph of this algorithm is a connected weighted graph, namely G, as shown in Figure 1. 

<img width="282" alt="image" src="https://github.com/badar24434/Delivery-Route-Optimization-Using-Dijkstra-s-Algorithm/assets/115607585/a79f3306-4ef1-4e1d-b4cf-392c94168e8e">






# Dijkstra's Algorithm Analysis

This repository provides an implementation of Dijkstra's algorithm using a Fibonacci heap, offering an efficient way to compute the shortest paths in a graph.

## Overview

The most efficient implementation of Dijkstra's algorithm leverages a Fibonacci heap. This data structure is a lazy heap, meaning it defers some operations to ensure others are extremely fast. The heap operations in a Fibonacci heap are very efficient due to its structure, where each node contains a pointer to its parent and one of its children, and a circular linked list connects the children nodes. This ensures that the heap maintains a pointer to the minimum distance node, facilitating very efficient operations.

## Time Complexity of Fibonacci Heap Operations Compared to Binary Heap

| Operation   | Binary Heap | Fibonacci Heap | Efficiency Improvement |
|-------------|-------------|----------------|------------------------|
| Insert      | O(log V)    | O(1)           | Significant improvement|
| ReturnMin   | O(1)        | O(1)           | No change              |
| DeleteMin   | O(log V)    | O(log V)       | No change              |
| Delete      | O(log V)    | O(log V)       | No change              |
| DecreaseKey | O(log V)    | O(1)           | Significant improvement|
| Merge       | O(1)        | O(1)           | No change              |

### Explanation of Efficiency Improvement

- **Insert**: The Fibonacci heap can perform insertions in constant time, O(1), compared to the O(log V) time in a binary heap. For \(n\) operations, this results in an improvement from O(log V) to O(1).

- **DecreaseKey**: Similarly, the DecreaseKey operation in a Fibonacci heap is O(1) compared to O(log V) in a binary heap. This leads to an overall improvement from O(log V) to O(1) for \(n\) DecreaseKey operations.

## Time Complexity Analysis
The use of a Fibonacci heap theoretically improves the efficiency of Dijkstra's algorithm, especially for dense graphs. The total time complexity for Dijkstra's algorithm with a Fibonacci heap is **O ( V log V+ E )** , where **V** is the number of vertices and **E** is the number of edges.

### Worst Case Time Complexity

- **Time Complexity**: *O( E + V log V)*
- **Explanation**: The worst case involves multiple decrease key operations. With a Fibonacci heap, each decrease key operation takes *O(1)* time. Since the inner loop operations occur *O(V + E)* times, the total complexity is *O(E + V log V )*.

### Average Case Time Complexity

- **Time Complexity**: *O(E + V log (E/V) V log V)*.
- **Explanation**: On average, the number of decrease key operations is limited by *O(V log (E/V))*. Multiplying this by the original complexity gives us the average time complexity of *O(E + V log (E/V) V log V)*.

### Best Case Time Complexity

- **Time Complexity**: *O(E + V log V)*
- **Explanation**: In the best case, the algorithm performs fewer decrease key operations. The complexity remains *O(E + V log V)* due to the base complexity of Fibonacci heap operations.

## Summary

Using a Fibonacci heap for Dijkstra's algorithm offers significant theoretical efficiency improvements, particularly for dense graphs:

- **Worst Case**: *O(E + V log V)*
- **Average Case**: *O(E + V log (E/V) V log V)*
- **Best Case**: *O(E + V log V)*
